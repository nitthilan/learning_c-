Setting up c++ environment:
===========================
- g++ -v - give the version of the c++ compiler
- cmake vs scons - scons uses python and a link said that scons is slow for larger projects and takes more coding for repetitive tasks. So using CMake
- Using CMAKE:
	- cmake CMakeLists.txt 
		- generates the Makefile which can be executed to generate the exe
		- generates a CMakeCache.txt file which has to be deleted whenever something is changed in CMakeList.txt file
		- generates a CMakeFiles folder
		- generates include files which are generated by configure method
	- better way would be to use
		- cd <location-of-cmakelists>/build && cmake ..
		- http://stackoverflow.com/questions/9680420/looking-for-a-cmake-clean-command-to-clear-up-cmake-output
		- this generates the header files and all the above specified files in a separate directory
		- To clean up the cmake cache is to rm -rf build to remove the generated files

- STL:
	- Reference:
		- https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-2/
		- https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-1/
	- Short note:
		- vector: push_back(a), empty(), size(), insert(a,@b), erase(frmA,toB), clear(), resize(), vector<int>::iterator
		- stack: push(T), T top(), pop(), size(), empty(), 
		- queue: push(T), T front(), pop(), size(), empty(), back()
		- iterator: .begin(), .end(), .rbegin(), .rend()
		- set: insert(T), erase(T), it find(T), O(LogN)
			- set iterator does not support [] and <,> operators only != is supported
		- map: insert(pair), erase(key), it find(key) O(logN)
		- unordered_map: inert(pair), erase(kay), it find(key), [key] is supported, at(key),
			- load_factor = size / bucket_count , bucket_count
		- priority_queue: push(T), T top(), pop()
	- Containers [Vectors]
		- vector<vector<int>> WrongDefinition; // Wrong: compiler may be confused by 'operator >>'. Use space.
		- vector<int> v(10) - allocates memory for 10 entries
		- vector<int> v; v.push_back(1); - dynamically allocates more memory. Not 1 entry. Size depends on internal implementation
		- v.resize(20) - reallocates new memroy for 20 entries
		- v.clear() - makes the number of elements zero and not the value to be made as zero
		- vector<string> names(20, “Unknown”); - creates and initialises with unknown
		- vector< vector<int> > Matrix; - 2D vector
		- vector< vector<int> > Matrix(N, vector<int>(M, -1)); - 2D vector of NxM initialised with -1
		- void some_function(vector<int> v) { }// Never do it unless you’re sure what you do! - This creates a copy of the vector (pass by value) and does not pass by reference
			- Use void some_function(const vector<int>& v) {}
		- vector.insert(index, value) - shifts all the elements from the index to the right
			- v.insert(1, all(v2));
		- v.erase(iterator), v.erase(begin, end) - deletes the elements in the index or from begin to end
	- Pairs
		- template<typename T1, typename T2> struct pair { T1 first; T2 second; }; 
		- pair<string, pair<int, int> > - pair of integers and a string
		- built-in operations to compare themselves.
		- If the first elements are not equal, the result will be based on the comparison of the first elements only; the second elements will be compared only if the first ones are equal.
		- Pairs are also widely used in associative containers
	- Iterators:
		- c.begin(), c.end() - end points to the first invalid element . So begin()-end() gives size of container
		- ++, -- should increment the iterator
		- Should be comparable using < , ==, >
		- *it should return the value of element
		- rbegin() and rend() are reverse iterators helping in reverse iteration of containers
		- “::iterator”, “::const_iterator”, “::reverse_iterator” or “::const_reverse_iterator”
			- vector<int>::iterator it = v.begin();
		- Using != instead of < and empty() instead of size() != 0 since their implementations are more efficient
		- void f(const vector<int>& v) { vector<int>::iterator it = v.begin(); // hm... where’s the error?.. }
			- const iterator should be used since input is const.
			- Since in const the value cannot be modified
		- (*it).element and it->element both work with iterators
			- set< pair<string, pair< int, vector<int> > > SS; tr(SS, it) { total += it->second.first; }
	- #include <algorithm>
		- min(a,b), max(a,b), swap(a,b)
			- swap(A[first], A[last]); // swap(a,b) is the standard STL function
		- std::reverse(T begin, T end) - implemented in #include<algorithm>
		- find(v.begin(), v.end(), 49) - v.begin() - returns the index of the first item found
			- set and map have the member functions find() and count(), which works in O(log N), while std::find() and std::count() take O(N)
		- *max_element(X.begin(), X.end()), *min_element(x.begin(), x.end()) - returns a iterator
		- sort(x.begin(), x.end()), using #define all(c) c.begin(), c.end() we can use sort(all(c))
			- sort(begin, end) sorts an interval in ascending order
			- sort() requires random access iterators, so it will not work on all containers.
			- map/set do not require sort since they are already stored in sorted order
		- next_permutation() and prev_permutation()
			- next_permutation(begin, end) makes the interval [begin, end) hold the next permutation of the same elements, or returns false if the current permutation is the last one. 
			- Don’t forget to ensure that the elements in a container are sorted before your first call to next_permutation(…). Their initial state should form the very first permutation; otherwise, some permutations will not be checked.
		- accumulate [#include <numeric>] [http://www.cplusplus.com/reference/numeric/accumulate/]
			- int sum = accumulate(begin, end, initial_value); - accumulates from begin to end adding the initial value
				- int sum = accumulate(all(v), 0);
			- result of accumulate() call always has the type of its third argument. if you are not sure that the sum fits in integer, specify the third parameter's type directly
				- long long sum = accumulate(all(v), (long long)0);
			- Accumulate can even calculate the product of values. The fourth parameter holds the predicate to use in calculations
				- double product = accumulate(all(v), double(1), multiplies<double>()); // don’t forget to start with 1 !
		- int r = inner_product(all(v1), v2.begin(), 0);
			- same as accumulator last value is initial value and return tye is same as the type of last value
		- non trivial sorting i.e for user defined datatypes
			- you require only operator < to be overloaded
			- your object should have default and copy constructor
			- 'operator <' should always return false for equal objects. It's very important 
	- functor: a class with operator () defined is functor
		- struct myclass {
			int operator()(int x, int y) {return x+3*y;}
		} myobject;
	- class BinaryOperation
		- example are functors like the above where operator () takes two arguments and return
		- functions which operate on two arguments
		- #include <functional> operators like std::minus<int>(), multiplies<double>()
	- class Function
	- typeof(x) - typeof is a compile time construct and returns the type as defined at compile time
		- typeid is a runtime construct and hence gives information about the runtime type of the value.
	- Using the below #define helps in traversing the container
		- #define tr(container, it) \ 
      		for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) 
      	- tr(v, it) { r += (*it)*(*it); }  -  defines the for loop
    - String:
    	- vector<char> and String has differences in memory management and string manipulation
    	- substr(start, length) 
    		- string str = "hello"; str.substr(1); // "ello"; str.substr(1,3); // "ell"; str.substr(0, 3);//"hel"
    	- Beware of (s.length()-1) on empty string because s.length() is unsigned and unsigned(0) – 1 is definitely not what you are expecting!
    - Set
    	- when to use map vs set
    		- add element without dupes
    		- remove elements
    		- get count of elements (without dupes)
    		- check whether element is present
    	- add(insert), remove(erase), check element present in O(logN), size() in O(1)
    	- push_back() is not applicable
    	- cannot use index to acces set and has to use only iterators
    	- set.erase(value) unlike vector.erase(iterator)
    	- interval constructor:
    		int data[5] = { 5, 1, 4, 2, 3 }; 
			set<int> S(data, data+5);
		- to remove duplicates from vector:
			vector<int> v; set<int> s(all(v)); vector<int> v2(all(s));
			- v2 is sorted and duplicate removed
	- Map
		- map<string, int> M;
		- map is very much like set, except it contains not just values but pairs <key, value>
		- M.erase(M.find("SRM")); // or even M.erase("SRM") 
		- map has operator [] defined
		- Traversing map is easy with our ‘tr()’ macros. Notice that iterator will be an std::pair of key and value. So, to get the value use it->second.
		- iterator of Map returns a pair - it->first = key, it->second = value
		- There is one important difference between map::find() and map::operator []. While map::find() will never change the contents of map, operator [] will create an element if it does not exist.
			- so the size increases for every element which is not present and so should not be used in loops etc if many elements are not present [http://www.cplusplus.com/reference/map/map/operator[]/]
		- That’s why operator [] may not be used if map is passed as a const reference parameter
	- Internally map and set are almost always stored as red-black trees.
		- map and set are always sorted in ascending order while traversing these containers.
		- And that’s why it’s strongly not recommended to change the key value while traversing map or set: If you make the modification that breaks the order, it will lead to improper functionality of container’s algorithms, at least.
		- operators ++ and — are defined on iterators in map and set
	- Using your own objects in Maps and Sets
		- "I only need to implement operator < for objects to be stored in set/map."
		- 
	- Memeory management of vectors:
		- Most STL implementations of vector double in size when push_back() is invoked and memory is not allocated.
		- The first approach is to use the reserve() member function of vector. This function orders vector to allocate additional memory. Vector will not enlarge on push_back() operations until the size specified by reserve() will be reached.
		- By the way, it’s a good pattern to use v.reserve() followed by copy(…, back_inserter(v)) for vectors.
		- Another is to, create a temporary vector with the same content as v, and then swap this temporary vector with 'v'. After the swap the original oversized v will be disposed.
			- vector<int> v; vector<int>(all(v)).swap(v);
    - find() - Multiple implementations
    	- find(start, end, value) - O(N) - generic implementation
    	- set/map/multiset/multimap/hash_map/hash_set - .find(val) - O(logN)
    		- if present returns the iterator else returns end() iterator
    		- if(s.find(42) != s.end()) { // 42 presents in set } else { // 42 not presents in set }
    - if(s.count(42) != 0) { }  - does not make sense to use in set/map since it is either present or not
    	- O(logN)
    - #define present(container, element) (container.find(element) != container.end()) 
 	  #define cpresent(container, element) (find(all(container),element) != container.end()) 
 		- present used with set/map
 		- cpresnt used with vector
 	- string streams: ‘istringstream’ and ‘ostringstream’.
 		- istringstream is(s); // Construct an object to parse strings 
 		- ostringstream os; // Constucvt an object to do formatted output 
 	- getting the values of map as vector so that it can be accessed as array index
 		- map<string, int> M; vector< pair<string, int> > V(all(M)); // remember all(c) stands for (c).begin(),(c).end()
 	- copying between containers
 		- copy(from_begin, from_end, to_begin); 
 		- from to to. to should have enough space for the copy
 		- vector<int> v1;vector<int> v2; // Now copy v2 to the end of v1; v1.resize(v1.size() + v2.size()); 
 			// Ensure v1 have enough space 
			copy(all(v2), v1.end() - v2.size()); // Copy v2 elements right after v1 ones
		- template <class Container, class Iterator> insert_iterator<Container> inserter (Container& x, Iterator it);
			- Constructs an insert iterator that inserts new elements into x in successive locations starting at the position pointed by it.
			- The type of x needs to have an insert member function
		- vector<int> v; set<int> s; // add some elements to set copy(all(v), inserter(s)); 
		- To insert elemements to vector with push_back use back_inserter, or front_inserter is available for deque container. 
		- And in some cases it is useful to remember that the first two arguments for ‘copy’ may be not only begin/end, but also rbegin/rend, which copy data in reverse order.
	- Merge lists:
		- different functions
			- set_union - ‘union’ the lists, R = A+B
			- set_intersection -  intersect the lists, R = A*B
			- set_difference - set difference, R = A*(~B) or R = A-B
			- set_symmetric_difference - set symmetric difference, R = A XOR B
		- usage: end_result = set_intersection(begin1, end1, begin2, end2, begin_result);
			- to get size alone int cnt = set_intersection(all(v1), all(v2), tmp.begin()) – tmp.begin();
			- vector<int> res = vi(temp, set_symmetric_difference(all(s1), all(s2), temp)); 
		- input datasets need to be sorted to use these algorithms.
		- map (pass pairs as inputs) and set can be used with these algorithms
	- Difference between int a[100];, std::vector<int> a, std::array<int, 3> a = {1,2,3};
		- http://stackoverflow.com/questions/4424579/stdvector-versus-stdarray-in-c/4424658#4424658
		- std::array is wrapper over c arrays
		- array size is fixed and cannot be changed like vector so efficient in small sizes
		- vector
	- Graph algorithms:
		- DFS - depth fist search, BFS - Breath first search, 
		- simplest way to store graph - vector< vector<int> > Vertex_map;
	- std::for_each
		- template<class InputIterator, class Function> Function for_each(InputIterator first, InputIterator last, Function fn){
			while (first!=last) {
				fn (*first);
				++first;
			}
			return fn;      // or, since C++11: return move(fn);
		}
	- stack, queue, priority_queue list, deque,
		- queue:
			- front() (first element), back() (last element), push() (== push_back() not there in queue) (add element to last), pop (== pop_front() not there in queue) (remove first element)
			- usage: push() - pushes a element in queue, front() - returns the value, pop() - does not return but removes the last element
			- if push_front() and pop_back() use deque
			- all above operations use O(1)
		- priority_queue is a BINARY HEAP
			- O(logN)
			- A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.
			- A user-provided Compare can be supplied to change the ordering, e.g. using std::greater<T> would cause the smallest element to appear as the top()
			- push() - add element, pop() - remove top element, top() - access top element
			- std::make_heap is simillar to priority_queue
			- priority_queue<ii, vector<ii>, greater<ii> > is used to get the lowest as the top of the heap
		- stack:
			- usage: push() - add top element, top() - access top element, pop() - remove top element
		- list and deque quite useless
	- copy constructor, default constructor, assignment operator??
		- http://www.geeksforgeeks.org/does-compiler-always-create-a-copy-constructor/
		- http://www.cplusplus.com/articles/y8hv0pDG/ - very good discussion
		- Many of the STL containers and algorithms require that an objectbe copyable. Typically, this means that you need to have thecopy constructor that takes a const reference, for the abovereasons.
		- Once you explicitly declare absolutely any constructor for a class, the compiler stops providing the implicit default constructor. If you still need the default constructor, you have to explicitly declare and define it yourself.
		- But, Compiler creates a copy constructor if we don’t write our own. Compiler creates it even if we have written other constructors in class. For example, the below program works fine.
		- copy constructor is a constructor with same class passed as input to initialise
		- default constructor is constuctor with no argument
		- Compiler created default constructor has empty body, i.e., it doesn’t assign default values to data members
		- http://en.cppreference.com/w/cpp/language/copy_constructor
	-  prototype of 'operator <' : return type bool, const modifier ??, parameter const reference??
	- shared_ptr, auto_ptr etc???

	- Dont's
		- struct fraction { 
		      int n, d; // (n/d) 
		      bool operator < (const fraction& f) const { 
		           if(false) {return (double(n)/d) < (double(f.n)/f.d);// Try to avoid this, you're the TopCoder!} 
		           else { return n*f.d < f.n*d; } 
		      } 
		 };
	- http://en.cppreference.com/w/
	- Unread references:
		- https://www.quora.com/Where-how-can-one-practice-C++-STL
		- http://www.devx.com/cplus/Article/42114
 	- Starter code and macros:
	 	typedef vector<int> vi; 
		typedef vector<vi> vvi; 
		typedef pair<int,int> ii; 
		#define sz(a) int((a).size()) 
		#define pb push_back 
		#defile all(c) (c).begin(),(c).end() 
		#define tr(c,i) for(typeof((c).begin() i = (c).begin(); i != (c).end(); i++) 
		#define present(c,x) ((c).find(x) != (c).end()) 
		#define cpresent(c,x) (find(all(c),x) != (c).end()) 
      
